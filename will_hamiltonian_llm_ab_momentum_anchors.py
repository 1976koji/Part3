#!/usr/bin/env python

# ---------- Áå´„Ç≥„Éº„Éë„Çπ ----------
# =========================================
# üê± Êó•Êú¨Ë™ûÁå´„Ç≥„Éº„Éë„ÇπÔºà100 ÊñáÔºâ
# =========================================
cats = [
    "ÁßÅ„ÅØÁå´„ÅåÂ•Ω„Åç„Å†„ÄÇ",
    "ÈªíÁå´„ÅÆ„Å§„ÇÑ„ÇÑ„Åã„Å™ÊØõ‰∏¶„Åø„ÇíË¶ã„Çã„Å®ÂøÉ„ÅåËêΩ„Å°ÁùÄ„Åè„ÄÇ",
    "Áå´„ÅÆ„Ç¥„É≠„Ç¥„É≠„Å®„ÅÑ„ÅÜÂñâÈ≥¥„Çâ„Åó„ÅØÊúÄÈ´ò„ÅÆÁôí„ÇÑ„Åó„Å†„ÄÇ",
    "ÊúùÊó•„ÇíÊµ¥„Å≥„Å¶‰º∏„Å≥„Çí„Åô„ÇãÁå´„ÅÆÂßø„ÅåÊÑõ„Åä„Åó„ÅÑ„ÄÇ",
    "Â≠êÁå´„ÅåÊÆµ„Éú„Éº„É´ÁÆ±„ÅÆ‰∏≠„Åß‰∏∏„Åæ„Å£„Å¶Áú†„Å£„Å¶„ÅÑ„Çã„ÄÇ",
    "‰∏âÊØõÁå´„ÅÆÊ®°Êßò„ÅØ‰∏ñÁïå„Å´‰∫å„Å§„Å®Âêå„Åò„ÇÇ„ÅÆ„Åå„Å™„ÅÑ„ÄÇ",
    "Áå´„ÅØÂ•ΩÂ•áÂøÉÊó∫Áõõ„Åß„ÄÅ„Åô„ÅêÈ´ò„ÅÑÊâÄ„Å´Áôª„Çä„Åü„Åå„Çã„ÄÇ",
    "Áã≠„ÅÑÈöôÈñì„Å´Âô®Áî®„Å´ÂÖ•„ÇäËæº„ÇÄ„ÅÆ„ÅØÁå´„Å™„Çâ„Åß„ÅØ„Å†„ÄÇ",
    "ËÇâÁêÉ„ÅÆ„Å∑„Å´„Å∑„Å´„Åó„ÅüÊÑüËß¶„Åå„Åü„Åæ„Çâ„Å™„ÅÑ„ÄÇ",
    "Èõ®„ÅÆÊó•„ÄÅÁ™ìËæ∫„ÅßÂ§ñ„ÇíÁú∫„ÇÅ„ÇãÁå´„ÅÆÊ®™È°î„ÅåË©©ÁöÑ„Å†„ÄÇ",
    "Â§úÊõ¥„Åë„Å´Èùô„Åã„Å´Ê≠©„ÅèÁå´„ÅÆË∂≥Èü≥„ÅØ„Åª„Å®„Çì„Å©ËÅû„Åì„Åà„Å™„ÅÑ„ÄÇ",
    "Áå´„ÅØÁ¥ôË¢ã„ÇíË¶ã„Çã„Å®ÂøÖ„Åö„Å®Ë®Ä„Å£„Å¶„ÅÑ„ÅÑ„Åª„Å©ÊΩú„ÇäËæº„ÇÄ„ÄÇ",
    "Á∑ëËâ≤„ÅÆÁû≥„Åå„É©„É≥„Éó„ÅÆ„Çà„ÅÜ„Å´ÊöóÈóá„ÅßÂÖâ„Çã„ÄÇ",
    "„Ç≠„É£„ÉÉ„Éà„Çø„ÉØ„Éº„ÅÆ„Å¶„Å£„Å∫„Çì„ÅØÂΩº„Çâ„ÅÆÁâπÁ≠âÂ∏≠„Å†„ÄÇ",
    "Áå´„Åò„ÇÉ„Çâ„Åó„ÇíÊåØ„Çã„Å®ÁõÆ„ÇíËºù„Åã„Åõ„Å¶È£õ„Å≥„Å§„Åè„ÄÇ",
    "ÊØõ„Å•„Åè„Çç„ÅÑ„Å´‰ΩôÂøµ„Åå„Å™„Åè„ÄÅÂ∏∏„Å´Ë∫´„Å†„Åó„Å™„Åø„ÅØÂÆåÁíß„ÄÇ",
    "È≠ö„ÅÆÂåÇ„ÅÑ„Åå„Åô„Çã„Å®Âè∞ÊâÄ„Å∏‰∏ÄÁõ¥Á∑ö„Å´Ëµ∞„Å£„Å¶Êù•„Çã„ÄÇ",
    "„ÉÄ„É≥„Éú„Éº„É´„ÇíÂôõ„Çì„Åß„Éú„É≠„Éú„É≠„Å´„Åô„Çã„ÅÆ„ÅåÊó•Ë™≤„ÄÇ",
    "Êó•Âêë„Åº„Å£„Åì„Çí„Åó„Å¶„ÅÑ„ÇãÂßø„ÅØ„Åæ„Çã„ÅßÂΩ´Âàª„ÅÆ„Çà„ÅÜ„ÄÇ",
    "Â§ïÊöÆ„ÇåÊôÇ„ÄÅË∑ØÂú∞Ë£è„ÅßÁå´ÂêåÂ£´„ÅåÊå®Êã∂„Çí‰∫§„Çè„Åó„Å¶„ÅÑ„Åü„ÄÇ",
    "Èï∑ÊØõÁ®Æ„ÅØ„Éñ„É©„ÉÉ„Ç∑„É≥„Ç∞„Åô„Çã„Å®Èõ≤„ÅÆ„Çà„ÅÜ„Å™ÊØõ„ÅåËàû„ÅÜ„ÄÇ",
    "Áå´„Ç´„Éï„Çß„Åß„ÅØÊôÇÈñì„ÅåÁµå„Å§„ÅÆ„ÇíÂøò„Çå„Å¶„Åó„Åæ„ÅÜ„ÄÇ",
    "„ÅîÈ£Ø„ÅÆÊôÇÈñì„Å´„Å™„Çã„Å®Èà¥„ÅÆ„Çà„ÅÜ„Å™Â£∞„ÅßÈ≥¥„ÅÑ„Å¶ÂÇ¨‰øÉ„Åô„Çã„ÄÇ",
    "„Ç∑„Éß„ÉÉ„Éî„É≥„Ç∞„Çµ„Ç§„Éà„ÅßÁå´Áî®„Åä„ÇÑ„Å§„ÇíÂ§ßÈáèË≥ºÂÖ•„Åó„Åü„ÄÇ",
    "Áå´„ÅØÊñ∞„Åó„ÅÑÊÆµ„Éú„Éº„É´ÁÆ±„ÇíË¶ã„Å§„Åë„Çã„Å®Âç≥Â∫ß„Å´ÊîØÈÖç„Åô„Çã„ÄÇ",
    "„Çπ„Ç≥„ÉÜ„Ç£„ÉÉ„Ç∑„É•„Éï„Ç©„Éº„É´„Éâ„ÅÆÊäò„Çå„ÅüËÄ≥„Åå„Ç≠„É•„Éº„Éà„Å†„ÄÇ",
    "„Ç´„Éº„ÉÜ„É≥„Å´„Çà„ÅòÁôª„Çâ„Çå„Å¶Á©¥„ÅåÈñã„ÅÑ„Åü„ÄÇ",
    "„ÇΩ„Éï„Ç°„ÅÆÈöÖ„ÅßÈ¶ôÁÆ±Â∫ß„Çä„Çí„Åó„Å¶„ÅÑ„Çã„ÄÇ",
    "Áå´„ÅØ‰∫∫Èñì„ÅÆË®ÄËëâ„ÅÆÊäëÊèö„Çí„Çà„ÅèËÅû„ÅçÂàÜ„Åë„Çã„Å®„ÅÑ„ÅÜ„ÄÇ",
    "Áå´Ëçâ„ÇíÈ£ü„Åπ„Å¶ËÉÉ„ÇíÊï¥„Åà„ÇãË≥¢„Åï„Å´ÊÑüÂøÉ„Åô„Çã„ÄÇ",
    "Êó©Êúù„ÄÅÊûïÂÖÉ„ÅßÂ∞è„Åï„Åè„Éã„É£„Éº„Å®È≥¥„ÅçËµ∑„Åì„Åó„Å¶„Åè„Çå„Çã„ÄÇ",
    "„ÅäËÖπ„ÇíË¶ã„Åõ„Å¶„Ç¥„É≠„É≥„Å®Ëª¢„Åå„Çã„ÅÆ„ÅØ‰ø°È†º„ÅÆË®º„ÄÇ",
    "„Åî„ÅØ„ÇìÁöø„ÅÆÈü≥„Å†„Åë„ÅßÈ£õ„Çì„Åß„Åè„ÇãËÅ¥Ë¶ö„ÅÆÈã≠„Åï„ÄÇ",
    "Áå´Áî®„ÅÆ„Éà„É≥„Éç„É´„Åä„ÇÇ„Å°„ÇÉ„ÅßÂª∂„ÄÖ„Å®ÈÅä„Çì„Åß„ÅÑ„Çã„ÄÇ",
    "„Ç≠„É£„ÉÉ„Éà„Ç¶„Ç©„Éº„ÇØ„Çí‰Ωú„Å£„Åü„ÇâÈÉ®Â±ã„ÅåÁ´ã‰ΩìÁöÑ„Å´‰Ωø„Çè„ÇåÂßã„ÇÅ„Åü„ÄÇ",
    "Áå´„ÅÆÈ≥¥„ÅçÂ£∞„Å´„ÅØ18Á®ÆÈ°û‰ª•‰∏ä„ÅÆ„Éë„Çø„Éº„É≥„Åå„ÅÇ„Çã„Çâ„Åó„ÅÑ„ÄÇ",
    "„Éï„É™„Çπ„Ç≠„Éº„ÇíÈñãÂ∞Å„Åô„Çã„Å®Ë¢ã„ÅÆÈü≥„Å´ÊïèÊÑü„Å´ÂèçÂøú„ÄÇ",
    "„Ç∑„É•„É¨„ÉÉ„ÉÄ„Éº„Åó„ÅüÁ¥ôÁâá„ÅÆ‰∏ä„Åß„Åµ„Åø„Åµ„Åø„ÇíÂßã„ÇÅ„Åü„ÄÇ",
    "„Ç≠„Ç∏„Éà„É©ÊüÑ„ÅØÊ£Æ„ÅÆ„Ç´„É¢„Éï„É©„Éº„Ç∏„É•Ê®°Êßò„Å†„ÄÇ",
    "Áå´„ÅÆÂ∞ªÂ∞æ„ÅØÊÑüÊÉÖ„ÅÆ„Éê„É≠„É°„Éº„Çø„Éº„ÄÇ",
    "ÁéÑÈñ¢„ÅßÂá∫Ëøé„Åà„Çã„Å®„Åç„ÅÆÂ∞èËµ∞„Çä„ÅåÂèØÊÑõ„ÅÑ„ÄÇ",
    "„Åì„Åü„Å§„Åã„ÇâÈ°î„Å†„ÅëÂá∫„Åó„Å¶ÂØùËêΩ„Å°„Åó„Å¶„ÅÑ„Çã„ÄÇ",
    "Ë™≠Êõ∏„ÇíÂßã„ÇÅ„Çã„Å®ÂøÖ„ÅöÊú¨„ÅÆ‰∏ä„Å´Â∫ß„Çã„ÄÇ",
    "È≥•„ÅÆ„Åï„Åà„Åö„Çä„Å´ÂèçÂøú„Åó„Å¶„ÉÜ„É¨„Éì„Çí„Çø„ÉÉ„ÉÅ„Åô„Çã„ÄÇ",
    "ÊØõÁéâ„ÇíÂêê„ÅÑ„ÅüÂæå„ÅØÂ∞ë„ÅóÁî≥„ÅóË®≥„Å™„Åï„Åù„ÅÜ„Å™Ë°®ÊÉÖ„ÄÇ",
    "Á†Ç„ÅÆ„Éà„Ç§„É¨„Çí‰∏ÅÂØß„Å´Êéò„Å£„Å¶„Åã„ÇâÁî®„ÇíË∂≥„Åô„ÄÇ",
    "Á™ì„Ç¨„É©„Çπ„Å´Êò†„ÇãËá™ÂàÜ„ÅÆÂßø„Å´„Éë„É≥„ÉÅ„ÇíÁπ∞„ÇäÂá∫„Åô„ÄÇ",
    "„Åä„ÇÇ„Å°„ÇÉ„ÅÆ„É¨„Éº„Ç∂„Éº„Éù„Ç§„É≥„Çø„ÇíÂÖ®Âäõ„ÅßËøΩ„ÅÑ„Åã„Åë„Çã„ÄÇ",
    "Áå´ËÉå„Å®Ë®Ä„ÅÜ„Åå„ÄÅ‰∏∏„Åæ„Å£„ÅüËÉå‰∏≠„ÅØÂÑ™ÈõÖ„Åß„ÇÇ„ÅÇ„Çã„ÄÇ",
    "„Å≠„Åö„Åø„ÅÆ„Åä„ÇÇ„Å°„ÇÉ„Çí„Åè„Çè„Åà„Å¶Êà¶Âà©ÂìÅ„Å®„Åó„Å¶ÊåÅ„Å£„Å¶„Åè„Çã„ÄÇ",
    "ÁôΩÁå´„ÅØÊúàÂÖâ„ÇíÊµ¥„Å≥„Çã„Å®ÂπΩÁéÑ„Å™Èõ∞Âõ≤Ê∞ó„ÇíÈÜ∏„Åô„ÄÇ",
    "„Ç≠„ÉÉ„ÉÅ„É≥„Ç´„Ç¶„É≥„Çø„Éº„Å´‰πó„Çâ„Å™„ÅÑ„Åß„Å®‰ΩïÂ∫¶Ê≥®ÊÑè„Åó„Åü„Åì„Å®„Åã„ÄÇ",
    "Âºï„ÅçÂá∫„Åó„ÇíÈñã„Åë„ÇãÈü≥„Åß„Åä„ÇÑ„Å§„Å†„Å®ÊÇü„Çã„ÄÇ",
    "ÁéÑÈñ¢„Éû„ÉÉ„Éà„ÅÆ‰∏ä„ÅßËÖπ„Å∞„ÅÑ„Å´„Å™„Å£„Å¶‰∫∫Èñì„ÇíÂæÖ„Å§„ÄÇ",
    "„Åô„ÇäÂØÑ„Å£„Å¶„Åè„Çã„Å®„Åç„ÅÆÈ†¨„ÅÆÊüî„Çâ„Åã„Åï„ÅåÂ•Ω„Åç„Å†„ÄÇ",
    "Áå´„ÅåËÜù„Å´‰πó„Çã„Å®Ë∫´Âãï„Åç„Åå„Å®„Çå„Å™„Åè„Å™„Çã„ÄåÁå´ÊãòÊùü„Äç„ÄÇ",
    "È´òÈÄü„Åß„Åó„Å£„ÅΩ„ÇíÊåØ„Çã„ÅÆ„ÅØ‰∏çÊ©üÂ´å„ÅÆ„Çµ„Ç§„É≥„ÄÇ",
    "È¶ñËº™„ÅÆÈà¥„Åå„ÉÅ„É™„É≥„Å®È≥¥„Çã„Åü„Å≥„Å´ÊâÄÂú®„Åå„Çè„Åã„Çã„ÄÇ",
    "Â§ú‰∏≠„Å´Â§ßÈÅãÂãï‰ºö„ÇíÈñãÂÇ¨„Åó„Å¶ÂÆ∂„ÅåÊè∫„Çå„Çã„ÄÇ",
    "„Ç≠„É£„ÉÉ„Éà„Éï„Éº„Éâ„ÅÆ„Éë„ÉÉ„Ç±„Éº„Ç∏„ÇíÈñã„Åë„Çã„Å®ÁõÆ„ÅåÁúüÂâ£„Å´„Å™„Çã„ÄÇ",
    "Â∏ÉÂõ£„Å´ÊΩú„ÇäËæº„Çì„ÅßË∂≥„ÇíÊ∏©„ÇÅ„Å¶„Åè„Çå„Çã„ÄÇ",
    "ËÅû„ÅçÊÖ£„Çå„Å™„ÅÑÊù•ÂÆ¢„ÅÆÂ£∞„Å´Ë≠¶Êàí„Åó„Å¶Èö†„Çå„Çã„ÄÇ",
    "Ê≠ØÁ£®„Åç„Ç¨„É†„ÇíÂôõ„ÇÄÂßø„ÅåÊÑèÂ§ñ„Å®„ÉØ„Ç§„É´„Éâ„ÄÇ",
    "Áç£Âåª„Åï„Çì„ÅÆË®∫ÂØüÂè∞„Åß„ÅØÂõ∫„Åæ„Å£„Å¶Áü≥ÂÉè„ÅÆ„Çà„ÅÜ„ÄÇ",
    "„Éà„Éº„Éà„Éê„ÉÉ„Ç∞„ÇíÁΩÆ„Åè„Å®‰∏≠„Å´ÂÖ•„ÇäÊóÖÊîØÂ∫¶„Åî„Å£„Åì„ÄÇ",
    "ÂØùË®Ä„ÅßÂ∞è„Åï„Åè„Éã„É£„ÉÉ„Å®È≥¥„ÅèÂ§ú„ÇÇ„ÅÇ„Çã„ÄÇ",
    "Êúù„ÅÆ„Çπ„Éà„É¨„ÉÉ„ÉÅ„ÅßËÉå‰∏≠„ÇíÂèç„Çâ„ÅôÂßø„Åå„É®„Ç¨„ÅÆÈÅî‰∫∫„ÄÇ",
    "„Åµ„Çè„Åµ„Çè„ÅÆÂ∞ªÂ∞æ„ÅßÈ°î„ÇíÊí´„Åß„Çâ„Çå„Å¶„Åè„Åô„Åê„Å£„Åü„ÅÑ„ÄÇ",
    "Áå´„Åå„ÅÑ„Çã„Å†„Åë„ÅßÈÉ®Â±ã„ÅÆÁ©∫Ê∞ó„ÅåÊüî„Çâ„Åã„Åè„Å™„Çã„ÄÇ",
    "ÊÆµ„Éú„Éº„É´Ëø∑Ë∑Ø„Çí‰Ωú„Å£„Åü„ÇâÊé¢Ê§úÈöäÈï∑„Å´„Å™„Å£„Åü„ÄÇ",
    "„Ç≠„É£„ÉÉ„Éà„Éã„ÉÉ„ÉóÂÖ•„Çä„ÅÆ„Åä„ÇÇ„Å°„ÇÉ„ÅßÈÖî„Å£„Å±„Çâ„ÅÜÊßòÂ≠ê„ÅåÈù¢ÁôΩ„ÅÑ„ÄÇ",
    "ËÉå‰∏≠„Çí„Éà„É≥„Éà„É≥„Åô„Çã„Å®„Éà„É≠„É≥„Å®ÁõÆ„ÇíÁ¥∞„ÇÅ„Çã„ÄÇ",
    "Á™ìËæ∫„ÅßËù∂„ÇíÁõÆ„ÅßËøΩ„ÅÜ„Éè„É≥„Çø„Éº„ÅÆË°®ÊÉÖ„ÄÇ",
    "ÈöéÊÆµ„Çí‰∏ÄÊÆµÈ£õ„Å∞„Åó„ÅßÈßÜ„Åë‰∏ä„Åå„ÇãË∑≥Ë∫çÂäõ„ÄÇ",
    "„Çπ„Éû„Éõ„ÅÆÁîªÈù¢„ÇíÁå´Áî®„Ç≤„Éº„É†„Å´„Åô„Çã„Å®ÁúüÂâ£„Åù„ÅÆ„ÇÇ„ÅÆ„ÄÇ",
    "„Ç≥„Éº„Éí„ÉºË±Ü„ÅÆÂåÇ„ÅÑ„Å´„ÅØËààÂë≥„ÇíÁ§∫„Åï„Å™„ÅÑ„ÄÇ",
    "„ÇØ„É™„Çπ„Éû„Çπ„ÉÑ„É™„Éº„Çí„Çà„ÅòÁôª„ÇäÈ£æ„Çä„ÇíËêΩ„Å®„Åô‰∫ã‰ª∂„ÄÇ",
    "Èõ∑„ÅåÈ≥¥„Çã„Å®„ÇØ„É≠„Éº„Çº„ÉÉ„Éà„ÅÆÂ••„Å∏ÈÅøÈõ£„ÄÇ",
    "„Ç∑„É£„É≥„Éó„ÉºÂæå„ÅÆ„Éâ„É©„Ç§„É§„Éº„Çø„Ç§„É†„ÅØÂ§ßÈ®í„Åé„ÄÇ",
    "Á™ì„ÅÆÁµêÈú≤„ÇíËàê„ÇÅ„Å¶ÊÄí„Çâ„Çå„Çã„ÄÇ",
    "Èï∑„ÅÑ„Å≤„Åí„ÅØÂ§úÈñì„ÅÆ„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥Ë£ÖÁΩÆ„ÄÇ",
    "„Åî„Çç„Çì„Å®Ê®™„Å´„Å™„Çä„ÅäËÖπ„ÇíÊí´„Åß„Å¶„Ç¢„Éî„Éº„É´„ÄÇ",
    "Áå´Ë¶èÊ†º„ÅÆÂπÖ„ÅÆÁ¥∞„ÅÑÊ£ö„ÇíÊ≠©„Åè„Éê„É©„É≥„ÇπÊÑüË¶ö„ÄÇ",
    "Êñ∞„Åó„ÅÑÂåÇ„ÅÑ„ÅÆÊúç„Çí„ÇØ„É≥„ÇØ„É≥„Å®„ÉÅ„Çß„ÉÉ„ÇØ„ÄÇ",
    "„Çø„Éñ„É¨„ÉÉ„Éà„ÅÆ„Éö„É≥ÂÖà„ÇíÁãô„Å£„Å¶Áã©„Çä„Çí„Åô„Çã„ÄÇ",
    "Ê¥óÊøØ„Éç„ÉÉ„Éà„ÇíË¶ã„Çã„Å®ÁóÖÈô¢„ÇíÈÄ£ÊÉ≥„Åó„Å¶ÈÄÉ„ÅíËÖ∞„ÄÇ",
    "ÂèãÈÅî„ÅÆÁä¨„Å®„ÅØÈÅ©Â∫¶„Å™Ë∑ùÈõ¢ÊÑü„Çí‰øù„Å§„ÄÇ",
    "Èçµ„ÅÆ„Ç∏„É£„É©„Ç∏„É£„É©Èü≥„Å´ÂèçÂøú„Åó„Å¶ÁéÑÈñ¢„Å∏„ÄÇ",
    "Áå´Áî®„Éñ„É©„Ç∑„ÇíË¶ã„Çã„Å®Âñú„Çì„ÅßÈ†≠„ÇíÊäº„Åó‰ªò„Åë„Çã„ÄÇ",
    "Áå´„ÅØÂÆ∂„Å´„Å§„Åè„Å®Ë®Ä„ÅÜ„Åå„ÄÅ‰∫∫„Å´„ÇÇ„Å°„ÇÉ„Çì„Å®Êáê„Åè„ÄÇ",
    "ÁÆ∏ÁΩÆ„Åç„ÇíËª¢„Åå„Åó„Å¶„Çµ„ÉÉ„Ç´„Éº„ÇíÂßã„ÇÅ„Çã„ÄÇ",
    "ÈõªÊ∞ó„Çπ„Éà„Éº„Éñ„ÅÆÂâç„ÇíÁã¨Âç†„Åó„Å¶Âãï„Åã„Å™„ÅÑ„ÄÇ",
    "È≥¥„ÅçÂ£∞„ÅßÊôÇÂàª„ÇíÁü•„Çâ„Åõ„ÇãÊ≠£Á¢∫„Å™ËÖπÊôÇË®à„ÄÇ",
    "„Çµ„É≥„Ç∞„É©„Çπ„Çí„Åã„Åë„ÅüÂÜôÁúü„Åå SNS „Åß„Éê„Ç∫„Å£„Åü„ÄÇ",
    "„ÉÑ„É≥„Éá„É¨„Å™ÊÖãÂ∫¶„ÇÇÈ≠ÖÂäõ„ÅÆ‰∏ÄÈÉ®„Å†„ÄÇ",
    "Èå≤Áîª„Åó„ÅüÈ≥•ÂãïÁîª„Çí„ÉÜ„É¨„Éì„Å´Êò†„Åô„Å®Â§ßËààÂ•Æ„ÄÇ",
    "„Ç≠„É£„É™„Éº„Ç±„Éº„Çπ„ÇíË¶ã„Çã„Å®ÊóÖË°å„ÅãÁóÖÈô¢„Åã„ÅßË°®ÊÉÖ„ÅåÂ§â„Çè„Çã„ÄÇ",
    "‰∫∫Èñì„ÅÆ„Åè„Åó„ÇÉ„Åø„Å´È©ö„ÅÑ„Å¶Â∞ªÂ∞æ„ÅåËÜ®„Çâ„ÇÄ„ÄÇ",
    "„Åä„ÇÑ„Å§„ÅÆË¢ã„ÇíÈö†„ÅôÂ†¥ÊâÄ„Çí„Åô„Åß„Å´Â≠¶Áøí„Åó„Å¶„ÅÑ„Çã„ÄÇ",
    "‰ªäÊó•„ÇÇ„ÄåÁßÅ„ÅØÁå´„ÅåÂ•Ω„Åç„Å†„Äç„Å®ÂÜçÁ¢∫Ë™ç„Åó„Åü„ÄÇ"
]

import os
os.environ["TOKENIZERS_PARALLELISM"] = "false"
import sys, random, pathlib
import torch # Import torch here
from typing import List, Callable, Tuple # Import Callable and Tuple here

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm

import openai
# API„Ç≠„Éº„ÇíÁí∞Â¢ÉÂ§âÊï∞„Åã„ÇâÂèñÂæó
openai.api_key = OPENAI_API_KEY 
if not openai.api_key:
    sys.exit("Áí∞Â¢ÉÂ§âÊï∞ OPENAI_API_KEY „ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")

# Colab „ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÁî®„ÉÅ„Çß„ÉÉ„ÇØ
try:
    from google.colab import files
except ImportError:
    files = None

# ---------------- ‰∏ÄËà¨Ë®≠ÂÆö ----------------
EPS             = 0.005    # ‚Üê Â∞èÂàª„Åø„Å´
DAMPING         = 0.97     # ‚Üê Êë©Êì¶Âº∑Âåñ
REFRESH_EVERY   = 200      # ‚Üê „Éé„Ç§„Ç∫Ê≥®ÂÖ•È†ªÂ∫¶„ÉÄ„Ç¶„É≥
SIGMA_REFRESH   = 0.002    # ‚Üê „Éé„Ç§„Ç∫ÊåØÂπÖ„ÉÄ„Ç¶„É≥
LAMBDA_AMP      = 1.0      # ‚Üê ÊÑèÊÄùÂºæÊÄßÈ†Ö„ÇíÂº±„ÇÅ„Çã
ALPHA           = 30.0     # ‚Üê „Ç¢„É≥„Ç´„ÉºÂº∑Âåñ
EPS_DELTA       = 0.2      # ‚Üê „Ç¢„É≥„Ç´„ÉºÂπÖÊã°Â§ß
SMOOTH_WIN      = 10       # ‚Üê Âπ≥ÊªëÂåñÁ™ì„ÇíÂ∫É„Åí„Çã

BASE_SEED       = 1234
TRIALS          = 1

OUTDIR = pathlib.Path("GPT_output2")
OUTDIR.mkdir(exist_ok=True)

# ---------------- Âüã„ÇÅËæº„Åø„É¢„Éá„É´ ----------------
from sentence_transformers import SentenceTransformer
embedder = SentenceTransformer(
    "sentence-transformers/all-MiniLM-L6-v2",
    device='cuda' if torch.cuda.is_available() else 'cpu'
)

def embed(text: str) -> np.ndarray:
    return embedder.encode(text, convert_to_numpy=True).astype(np.float32)

# ---------------- „ÉÜ„Ç≠„Çπ„ÉàÁîüÊàê ----------------
def generate_text(seed: str, use_will: bool) -> str:
    prompt = (
        f"{seed}\n"
        "„Åì„ÅÆÊñáÁ´†„ÅÆÁ∂ö„Åç„ÇíËá™ÁÑ∂„Å™Êó•Êú¨Ë™û„Åß100ÊñáÂ≠óÁ®ãÂ∫¶„ÅßÂÆåÁµê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
    )
    # v1.0.0 ‰ª•Èôç„ÅÆ Chat API Âëº„Å≥Âá∫„Åó
    resp = openai.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role":"user","content":prompt}],

        temperature=0.7 if use_will else 0.7,
        top_p=0.9 if use_will else 0.9,

        max_tokens=80,
        n=1
    )
    text = resp.choices[0].message.content.strip().replace("\n", " ")
    return text

# ---------------- Œ¥-approx ----------------
def delta_eps(q: np.ndarray, q0: np.ndarray, eps: float = EPS_DELTA) -> float:
    d = np.linalg.norm(q - q0)
    return np.exp(-d * d / (2 * eps * eps)) / (eps * np.sqrt(2 * np.pi))

# ---------------- „Çπ„ÉÜ„ÉÉ„ÉóÈñ¢Êï∞ ----------------
def leapfrog_base(q, p, q0, lam):
    grad = lam * (q - q0)
    p = DAMPING * (p - 0.5 * EPS * grad)
    q = q + EPS * p
    p = DAMPING * (p - 0.5 * EPS * grad)
    return q, p


def leapfrog_will(q, p, q0, q_will, lam):
    gradV = q / (np.linalg.norm(q) + 1e-8)
    gradŒ¥ = delta_eps(q, q_will) * (-(q - q_will) / (EPS_DELTA ** 2))
    gradP = gradV
    dW = ALPHA * gradŒ¥ + gradV - lam * gradP
    p = DAMPING * (p - 0.5 * EPS * dW)
    q = q + EPS * p
    p = DAMPING * (p - 0.5 * EPS * dW)
    return q, p

# ---------------- „Ç≥„Éº„Éë„ÇπË™≠„ÅøËæº„Åø ----------------
def load_corpus() -> list:
    try:
        cats
        return list(cats)
    except NameError:
        sys.exit("cats = [...] „ÇíÂÆöÁæ©„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")

# ---------------- ÂÆüÈ®ìÈñ¢Êï∞ ----------------
def run_experiment(lambda_fn: Callable[[int], float], use_will: bool, offset: int = 0):
    random.seed(BASE_SEED + offset)
    np.random.seed(BASE_SEED + offset)
    corpus = load_corpus()
    q0 = embed(corpus[0])
    q_will = q0.copy()
    q = q0.copy()
    p = np.zeros_like(q0)

    records = []
    for step, seed in enumerate(tqdm(corpus, desc=f"{'WiLL' if use_will else 'Base'} T{offset+1}"), start=1):
        txt = generate_text(seed, use_will)
        q_new = embed(txt)
        lam = lambda_fn(step) * LAMBDA_AMP
        if use_will:
            q, p = leapfrog_will(q_new, p, q0, q_will, lam)
        else:
            q, p = leapfrog_base(q_new, p, q0, lam)
        if step % REFRESH_EVERY == 0:
            p = np.random.normal(scale=SIGMA_REFRESH, size=p.shape)
        records.append({
            "step": step,
            "drift": np.linalg.norm(q - q0),
            "pnorm": np.linalg.norm(p),
            "A_q": float((q0 / np.linalg.norm(q0)) @ q)
        })
    df = pd.DataFrame(records)
    df["will"] = use_will
    df["trial"] = offset + 1
    return df

# ---------------- „É°„Ç§„É≥ ----------------
def main():
    corpus = load_corpus()
    # „Çµ„É≥„Éó„É´Âá∫Âäõ
    print("\n>> Sample Baseline")
    for i, s in enumerate(corpus[:3], 1):
        print(f"[Base {i}] {generate_text(s, False)}")
    print("\n>> Sample WiLL")
    for i, s in enumerate(corpus[:3], 1):
        print(f"[WiLL {i}] {generate_text(s, True)}")

    # AB„ÉÜ„Çπ„Éà
    all_df = []
    lambda_sched = lambda t: 1 + np.sin(2 * np.pi * t / 50)
    for use, label in [(False, "Baseline"), (True, "WiLL")]:
        for t in range(TRIALS):
            print(f"\n=== {label} Trial {t+1}/{TRIALS} ===")
            all_df.append(run_experiment(lambda_sched, use, t))
    df = pd.concat(all_df, ignore_index=True)

    # Ë¶ÅÁ¥ÑÁµ±Ë®àÈáè
    print("\n=== Summary Statistics (printf) ===")
    for use, label in [(False, "Baseline"), (True, "WiLL")]:
        sub = df[df.will == use]
        for metric in ["drift", "pnorm", "A_q"]:
            arr = sub[metric]
            print(
                f"printf: {label} {metric} "
                f"mean={arr.mean():.4f} std={arr.std():.4f} "
                f"min={arr.min():.4f} median={arr.median():.4f} max={arr.max():.4f}"
            )

    # ÊôÇÁ≥ªÂàó„Éó„É≠„ÉÉ„Éà
    for metric in ["drift", "pnorm", "A_q"]:
        plt.figure(figsize=(6, 4))
        for use, label in [(False, "Base"), (True, "WiLL")]:
            sub = df[df.will == use]
            plt.plot(sub.step, sub[metric], alpha=0.5, label=label)
        plt.title(metric)
        plt.xlabel("step")
        plt.legend()
        plt.grid(True)
        path = OUTDIR / f"{metric}_timeseries2_GPT.png"
        plt.tight_layout()
        plt.savefig(path, dpi=300)
        plt.show()
        if files:
            files.download(str(path))

    # Âπ≥Âùá„Éê„Éº„Ç∞„É©„Éï
    stats = df.groupby("will")[ ["drift", "pnorm", "A_q"] ].mean().rename({False: "Base", True: "WiLL"})
    stats.plot.bar(figsize=(8, 3))
    plt.title("Mean Metrics by Mode")
    plt.ylabel("Value")
    plt.grid(axis="y")
    bar_path = OUTDIR / "GPT_mean_metrics2.png"
    plt.tight_layout()
    plt.savefig(bar_path, dpi=300)
    plt.show()
    if files:
        files.download(str(bar_path))

    # CSV‰øùÂ≠ò
    csv_path = OUTDIR / "GPT_metrics2.csv"
    df.to_csv(csv_path, index=False)
    print(f"\nSaved CSV: {csv_path}")
    if files:
        files.download(str(csv_path))

if __name__ == "__main__":
    main()
